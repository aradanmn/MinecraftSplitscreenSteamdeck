#!/bin/bash
# =============================================================================
# @file        launcher_script_generator.sh
# @version     3.0.0
# @date        2026-01-25
# @author      Minecraft Splitscreen Steam Deck Project
# @license     MIT
# @repository  https://github.com/aradanmn/MinecraftSplitscreenSteamdeck
#
# @description
#   Generates the minecraftSplitscreen.sh launcher script with correct paths
#   baked in based on the detected launcher configuration. The generated script
#   handles Steam Deck Game Mode detection, controller counting, splitscreen
#   configuration, and instance launching.
#
#   Key features:
#   - Template-based script generation with placeholder replacement
#   - Support for both AppImage and Flatpak launchers
#   - Steam Deck Game Mode detection with nested Plasma session
#   - Controller detection with Steam Input duplicate handling
#   - Per-instance splitscreen.properties configuration
#
# @dependencies
#   - git (for commit hash embedding, optional)
#   - sed (for placeholder replacement)
#
# @exports
#   Functions:
#     - generate_splitscreen_launcher : Main generation function
#     - verify_generated_script       : Validation utility
#     - print_generation_config       : Debug/info utility
#
# @changelog
#   2.0.0 (2026-01-25) - Added comprehensive JSDoc documentation
#   1.0.0 (2024-XX-XX) - Initial implementation
# =============================================================================

# =============================================================================
# MAIN GENERATOR FUNCTION
# =============================================================================

# @function    generate_splitscreen_launcher
# @description Generate the minecraftSplitscreen.sh launcher script with
#              configuration values baked in via placeholder replacement.
# @param       $1 - output_path: Path for the generated script
# @param       $2 - launcher_name: "PollyMC" or "PrismLauncher"
# @param       $3 - launcher_type: "appimage" or "flatpak"
# @param       $4 - launcher_exec: Full path or flatpak command
# @param       $5 - launcher_dir: Launcher data directory
# @param       $6 - instances_dir: Instances directory path
# @global      SCRIPT_VERSION - (input, optional) Version string for embedding
# @global      REPO_URL - (input, optional) Repository URL for embedding
# @return      0 on success
# @example
#   generate_splitscreen_launcher "/path/to/script.sh" "PollyMC" "flatpak" \
#       "flatpak run org.fn2006.PollyMC" "/home/user/.var/app/org.fn2006.PollyMC/data/PollyMC" \
#       "/home/user/.var/app/org.fn2006.PollyMC/data/PollyMC/instances"
generate_splitscreen_launcher() {
    local output_path="$1"
    local launcher_name="$2"
    local launcher_type="$3"
    local launcher_exec="$4"
    local launcher_dir="$5"
    local instances_dir="$6"

    # Get version info
    local generation_date
    local commit_hash
    generation_date=$(date -Iseconds 2>/dev/null || date "+%Y-%m-%dT%H:%M:%S%z")
    commit_hash=$(git rev-parse --short HEAD 2>/dev/null || echo "unknown")

    # Ensure output directory exists
    mkdir -p "$(dirname "$output_path")"

    # Generate the script using heredoc
    # Note: We use a mix of quoted and unquoted heredoc markers:
    # - 'EOF' (quoted) prevents variable expansion in the heredoc
    # - We then use sed to replace placeholders with actual values
    cat > "$output_path" << 'LAUNCHER_SCRIPT_EOF'
#!/bin/bash
# =============================================================================
# Minecraft Splitscreen Launcher for Steam Deck & Linux
# =============================================================================
# Version: __SCRIPT_VERSION__ (commit: __COMMIT_HASH__)
# Generated: __GENERATION_DATE__
# Generator: install-minecraft-splitscreen.sh v__SCRIPT_VERSION__
# Source: __REPO_URL__
#
# DO NOT EDIT - This file is auto-generated by the installer.
# To update, re-run the installer script.
# =============================================================================
#
# This script launches 1-4 Minecraft instances in splitscreen mode.
# On Steam Deck Game Mode, it launches a nested KDE Plasma session.
# On desktop mode, it launches Minecraft instances directly.
#
# Features:
# - Controller detection (1-4 players)
# - Per-instance splitscreen configuration
# - KDE panel hiding/restoring
# - Steam Input duplicate device handling
# - Nested Plasma session for Steam Deck Game Mode
# =============================================================================

set +e  # Allow script to continue on errors for robustness

# =============================================================================
# GENERATED CONFIGURATION - DO NOT MODIFY
# =============================================================================
# These values were set by the installer based on your system configuration.

LAUNCHER_NAME="__LAUNCHER_NAME__"
LAUNCHER_TYPE="__LAUNCHER_TYPE__"
LAUNCHER_EXEC="__LAUNCHER_EXEC__"
LAUNCHER_DIR="__LAUNCHER_DIR__"
INSTANCES_DIR="__INSTANCES_DIR__"

# =============================================================================
# END GENERATED CONFIGURATION
# =============================================================================

# =============================================================================
# DYNAMIC SPLITSCREEN STATE (Rev 3.0.0)
# =============================================================================
# These variables track the state of dynamic splitscreen sessions where
# players can join and leave mid-game.

declare -a INSTANCE_PIDS=("" "" "" "")     # PID for each player slot (index 0-3)
declare -a INSTANCE_ACTIVE=(0 0 0 0)       # 1 if slot is in use, 0 otherwise
CURRENT_PLAYER_COUNT=0                      # Number of active players
DYNAMIC_MODE=0                              # 1 if dynamic mode enabled
CONTROLLER_MONITOR_PID=""                   # PID of monitor subprocess
CONTROLLER_PIPE=""                          # Path to named pipe for controller events

# =============================================================================
# END DYNAMIC SPLITSCREEN STATE
# =============================================================================

# Temporary directory for intermediate files
export target=/tmp

# =============================================================================
# LOGGING (prints to terminal AND logs to file)
# =============================================================================

LOG_DIR="$HOME/.local/share/MinecraftSplitscreen/logs"
LOG_FILE=""

_init_log() {
    mkdir -p "$LOG_DIR" 2>/dev/null || { LOG_DIR="/tmp/MinecraftSplitscreen/logs"; mkdir -p "$LOG_DIR"; }
    LOG_FILE="$LOG_DIR/launcher-$(date +%Y-%m-%d-%H%M%S).log"
    # Rotate old logs (keep last 10)
    local c=0; while IFS= read -r f; do c=$((c+1)); [[ $c -gt 10 ]] && rm -f "$f"; done < <(ls -t "$LOG_DIR"/launcher-*.log 2>/dev/null)
    { echo "=== Minecraft Splitscreen Launcher ==="; echo "Started: $(date)"; echo ""; } >> "$LOG_FILE"
}

log() { [[ -n "$LOG_FILE" ]] && echo "[$(date '+%H:%M:%S')] $*" >> "$LOG_FILE" 2>/dev/null; }
log_info() { echo "[Info] $*"; log "INFO: $*"; }
log_error() { echo "[Error] $*" >&2; log "ERROR: $*"; }
log_warning() { echo "[Warning] $*"; log "WARNING: $*"; }

_init_log

# =============================================================================
# Launcher Validation
# =============================================================================

# Validate that the configured launcher is available
validate_launcher() {
    local launcher_available=false

    if [[ "$LAUNCHER_TYPE" == "flatpak" ]]; then
        # For Flatpak, check if the app is installed
        local flatpak_id
        case "$LAUNCHER_NAME" in
            "PollyMC") flatpak_id="org.fn2006.PollyMC" ;;
            "PrismLauncher") flatpak_id="org.prismlauncher.PrismLauncher" ;;
        esac
        if command -v flatpak >/dev/null 2>&1 && flatpak list --app 2>/dev/null | grep -q "$flatpak_id"; then
            launcher_available=true
        fi
    else
        # For AppImage, check if the executable exists
        # Handle both direct path and "flatpak run" style commands
        local exec_path
        exec_path=$(echo "$LAUNCHER_EXEC" | awk '{print $1}')
        if [[ -x "$exec_path" ]] || command -v "$exec_path" >/dev/null 2>&1; then
            launcher_available=true
        fi
    fi

    if [[ "$launcher_available" == false ]]; then
        log_error "$LAUNCHER_NAME not found!"
        log_error "Expected: $LAUNCHER_EXEC"
        log_error "Please re-run the Minecraft Splitscreen installer."
        return 1
    fi

    return 0
}

# Validate launcher at startup
if ! validate_launcher; then
    exit 1
fi

log_info "Using $LAUNCHER_NAME ($LAUNCHER_TYPE) for splitscreen gameplay"
log_info "Log file: $LOG_FILE"

# =============================================================================
# Nested Plasma Session (Steam Deck Game Mode)
# =============================================================================

# Launches a nested KDE Plasma Wayland session and sets up Minecraft autostart.
# Needed so Minecraft can run in a clean, isolated desktop environment.
nestedPlasma() {
    # Unset variables that may interfere with launching a nested session
    unset LD_PRELOAD XDG_DESKTOP_PORTAL_DIR XDG_SEAT_PATH XDG_SESSION_PATH

    # Get current screen resolution
    local RES
    RES=$(xdpyinfo 2>/dev/null | awk '/dimensions/{print $2}')
    [ -z "$RES" ] && RES="1280x800"

    # Create a wrapper for kwin_wayland with the correct resolution
    cat <<EOF > "$target/kwin_wayland_wrapper"
#!/bin/bash
/usr/bin/kwin_wayland_wrapper --width ${RES%x*} --height ${RES#*x} --no-lockscreen \$@
EOF
    chmod +x "$target/kwin_wayland_wrapper"
    export PATH="$target:$PATH"

    # Write an autostart .desktop file that will re-invoke this script
    local SCRIPT_PATH
    SCRIPT_PATH="$(readlink -f "$0")"
    mkdir -p ~/.config/autostart
    cat <<EOF > ~/.config/autostart/minecraft-launch.desktop
[Desktop Entry]
Name=Minecraft Split Launch
Exec=$SCRIPT_PATH launchFromPlasma
Type=Application
X-KDE-AutostartScript=true
EOF

    # Start nested Plasma session (never returns)
    exec dbus-run-session startplasma-wayland
}

# =============================================================================
# Game Launching
# =============================================================================

# Launch a single Minecraft instance with KDE inhibition
# Arguments:
#   $1 = Instance name (e.g., latestUpdate-1)
#   $2 = Player name (e.g., P1)
launchGame() {
    local instance_name="$1"
    local player_name="$2"

    if command -v kde-inhibit >/dev/null 2>&1; then
        kde-inhibit --power --screenSaver --colorCorrect --notifications \
            $LAUNCHER_EXEC -l "$instance_name" -a "$player_name" &
    else
        log_warning "kde-inhibit not found. Running $LAUNCHER_NAME without KDE inhibition."
        $LAUNCHER_EXEC -l "$instance_name" -a "$player_name" &
    fi

    sleep 10  # Give time for the instance to start
}

# =============================================================================
# KDE Panel Management
# =============================================================================

# Hide KDE panels by killing plasmashell
hidePanels() {
    if command -v plasmashell >/dev/null 2>&1; then
        pkill plasmashell
        sleep 1
        if pgrep -u "$USER" plasmashell >/dev/null; then
            killall plasmashell
            sleep 1
        fi
        if pgrep -u "$USER" plasmashell >/dev/null; then
            pkill -9 plasmashell
            sleep 1
        fi
    else
        log_info "plasmashell not found. Skipping KDE panel hiding."
    fi
}

# Restore KDE panels by restarting plasmashell
restorePanels() {
    if command -v plasmashell >/dev/null 2>&1; then
        nohup plasmashell >/dev/null 2>&1 &
        sleep 2
    else
        log_info "plasmashell not found. Skipping KDE panel restore."
    fi
}

# =============================================================================
# Controller Detection
# =============================================================================

# Detect the number of controllers (1-4)
# Handles Steam Input device duplication when Steam is running
getControllerCount() {
    local count=0
    local steam_running=0
    local real_controllers=0

    # Method 1: Count actual gamepad/joystick devices from /proc/bus/input/devices
    # This is more reliable than /dev/input/js* as it works across different udev configs
    # Filter for actual gamepads (have js handler) and exclude virtual/Steam duplicates
    if [ -f /proc/bus/input/devices ]; then
        # Count unique physical controllers by looking at the Handlers line with "js"
        # and filtering by Sysfs path - uhid devices are real, virtual/input are Steam duplicates
        real_controllers=$(grep -B5 "Handlers=.*js[0-9]" /proc/bus/input/devices 2>/dev/null | \
            grep -c "Sysfs=.*/uhid/" 2>/dev/null || echo "0")
    fi

    # Method 2: Fallback to /dev/input/js* if method 1 fails
    if [ "$real_controllers" -eq 0 ]; then
        count=$(ls /dev/input/js* 2>/dev/null | wc -l)
    else
        count=$real_controllers
    fi

    # Method 3: Final fallback to sysfs
    if [ "$count" -eq 0 ]; then
        count=$(ls /sys/class/input/js* 2>/dev/null | wc -l)
    fi

    # Check if Steam is running (native or Flatpak) - expanded patterns for Bazzite/SteamOS
    if pgrep -x steam >/dev/null 2>&1 \
        || pgrep -f '/steam$' >/dev/null 2>&1 \
        || pgrep -f 'ubuntu12_32/steam' >/dev/null 2>&1 \
        || pgrep -f '^/app/bin/steam$' >/dev/null 2>&1 \
        || pgrep -f 'flatpak run com.valvesoftware.Steam' >/dev/null 2>&1; then
        steam_running=1
    fi

    # Only halve if we used fallback methods (not the uhid filtering method)
    # The uhid method already filters out Steam duplicates
    if [ "$steam_running" -eq 1 ] && [ "$real_controllers" -eq 0 ]; then
        count=$(( (count + 1) / 2 ))
    fi

    # Clamp between 1 and 4
    [ "$count" -gt 4 ] && count=4
    [ "$count" -lt 1 ] && count=1

    echo "[Debug] Controller detection: real=$real_controllers, total=$count, steam=$steam_running" >&2
    echo "$count"
}

# =============================================================================
# Controller Hotplug Monitoring (Dynamic Splitscreen)
# =============================================================================
# These functions enable real-time monitoring of controller connections
# and disconnections for dynamic player join/leave functionality.

# Monitor controller connections/disconnections
# Writes "CONTROLLER_CHANGE:<count>" to stdout when changes detected
# Uses inotifywait for efficiency, falls back to polling if unavailable
monitorControllers() {
    local last_count
    last_count=$(getControllerCount)

    # Prefer inotifywait (event-driven, efficient)
    if command -v inotifywait >/dev/null 2>&1; then
        log "Using inotifywait for controller monitoring"
        inotifywait -m -q -e create -e delete /dev/input/ 2>/dev/null | while read -r _ action file; do
            if [[ "$file" =~ ^js[0-9]+$ ]]; then
                sleep 0.5  # Debounce rapid events
                local new_count
                new_count=$(getControllerCount)
                if [ "$new_count" != "$last_count" ]; then
                    echo "CONTROLLER_CHANGE:$new_count"
                    last_count=$new_count
                fi
            fi
        done
    else
        # Fallback: poll every 2 seconds
        log "inotifywait not available, using polling for controller monitoring"
        while true; do
            sleep 2
            local new_count
            new_count=$(getControllerCount)
            if [ "$new_count" != "$last_count" ]; then
                echo "CONTROLLER_CHANGE:$new_count"
                last_count=$new_count
            fi
        done
    fi
}

# Start controller monitoring in background
# Creates a named pipe for IPC and spawns monitor subprocess
startControllerMonitor() {
    # Create a named pipe for communication
    CONTROLLER_PIPE="/tmp/mc-splitscreen-$$"
    rm -f "$CONTROLLER_PIPE" 2>/dev/null
    mkfifo "$CONTROLLER_PIPE" 2>/dev/null || {
        log_warning "Failed to create named pipe, controller monitoring disabled"
        return 1
    }

    # Start monitor in background, writing to pipe
    monitorControllers > "$CONTROLLER_PIPE" &
    CONTROLLER_MONITOR_PID=$!

    # Open pipe for reading on fd 3
    exec 3< "$CONTROLLER_PIPE"

    log_info "Controller monitor started (PID: $CONTROLLER_MONITOR_PID)"
    return 0
}

# Stop controller monitoring and clean up resources
stopControllerMonitor() {
    if [ -n "$CONTROLLER_MONITOR_PID" ]; then
        kill "$CONTROLLER_MONITOR_PID" 2>/dev/null || true
        wait "$CONTROLLER_MONITOR_PID" 2>/dev/null || true
        CONTROLLER_MONITOR_PID=""
        log "Controller monitor stopped"
    fi

    # Close fd 3 and clean up pipe
    exec 3<&- 2>/dev/null || true
    if [ -n "$CONTROLLER_PIPE" ]; then
        rm -f "$CONTROLLER_PIPE" 2>/dev/null || true
        CONTROLLER_PIPE=""
    fi
}

# =============================================================================
# Instance Lifecycle Management (Dynamic Splitscreen)
# =============================================================================
# Functions to track and manage individual Minecraft instance processes
# for dynamic join/leave functionality.

# Launch a single instance for a player slot
# Arguments:
#   $1 = slot number (1-4)
#   $2 = total players for layout calculation
launchInstanceForSlot() {
    local slot=$1
    local total_players=$2
    local idx=$((slot - 1))

    # Configure splitscreen position using existing function
    setSplitscreenModeForPlayer "$slot" "$total_players"

    # Launch the game in background
    launchGame "latestUpdate-$slot" "P$slot" &
    local pid=$!

    # Track the instance
    INSTANCE_PIDS[$idx]=$pid
    INSTANCE_ACTIVE[$idx]=1

    log_info "Launched instance $slot (PID: $pid) in $total_players-player layout"
}

# Check if an instance is still running
# Arguments:
#   $1 = slot number (1-4)
# Returns: 0 if running, 1 if not
isInstanceRunning() {
    local slot=$1
    local idx=$((slot - 1))
    local pid="${INSTANCE_PIDS[$idx]}"

    if [ -n "$pid" ] && kill -0 "$pid" 2>/dev/null; then
        return 0
    fi
    return 1
}

# Get next available slot (1-4)
# Outputs: slot number, or empty string if all full
getNextAvailableSlot() {
    for i in 1 2 3 4; do
        local idx=$((i - 1))
        if [ "${INSTANCE_ACTIVE[$idx]}" = "0" ]; then
            echo "$i"
            return 0
        fi
    done
    echo ""
}

# Count currently active instances
# Outputs: number of active instances (0-4)
countActiveInstances() {
    local count=0
    for i in 0 1 2 3; do
        if [ "${INSTANCE_ACTIVE[$i]}" = "1" ]; then
            count=$((count + 1))
        fi
    done
    echo "$count"
}

# Mark an instance as stopped (called when instance exits)
# Arguments:
#   $1 = slot number (1-4)
markInstanceStopped() {
    local slot=$1
    local idx=$((slot - 1))
    INSTANCE_PIDS[$idx]=""
    INSTANCE_ACTIVE[$idx]=0
    log "Instance $slot marked as stopped"
}

# =============================================================================
# Window Repositioning (Dynamic Splitscreen)
# =============================================================================
# Functions to reposition Minecraft windows when player count changes.
# Uses xdotool/wmctrl on X11, falls back to restarting instances in Game Mode.

# Check if external window management is available
# Returns: 0 if available (X11 with tools), 1 if not
canUseExternalWindowManagement() {
    # Must have a display
    if [ -z "$DISPLAY" ]; then
        return 1
    fi

    # Not available in gamescope/Game Mode
    if isSteamDeckGameMode; then
        return 1
    fi

    # Check for window management tools
    if command -v xdotool >/dev/null 2>&1 || command -v wmctrl >/dev/null 2>&1; then
        return 0
    fi

    return 1
}

# Get window ID for a Minecraft instance by PID
# Arguments:
#   $1 = process PID
# Outputs: window ID or empty string
getWindowIdForPid() {
    local pid=$1
    local window_id=""

    if command -v xdotool >/dev/null 2>&1; then
        # xdotool can search by PID - wait briefly for window to appear
        sleep 0.5
        window_id=$(xdotool search --pid "$pid" 2>/dev/null | head -1)
    elif command -v wmctrl >/dev/null 2>&1; then
        # wmctrl needs window list parsing
        window_id=$(wmctrl -lp 2>/dev/null | awk -v pid="$pid" '$3 == pid {print $1; exit}')
    fi

    echo "$window_id"
}

# Move and resize a window
# Arguments:
#   $1 = window_id, $2 = x, $3 = y, $4 = width, $5 = height
moveResizeWindow() {
    local window_id=$1
    local x=$2 y=$3 width=$4 height=$5

    if [ -z "$window_id" ]; then
        return 1
    fi

    if command -v xdotool >/dev/null 2>&1; then
        xdotool windowmove "$window_id" "$x" "$y" 2>/dev/null
        xdotool windowsize "$window_id" "$width" "$height" 2>/dev/null
    elif command -v wmctrl >/dev/null 2>&1; then
        wmctrl -i -r "$window_id" -e "0,$x,$y,$width,$height" 2>/dev/null
    fi
}

# Get screen dimensions
# Outputs: "width height" (e.g., "1920 1080")
getScreenDimensions() {
    local width=1920
    local height=1080

    if command -v xdpyinfo >/dev/null 2>&1 && [ -n "$DISPLAY" ]; then
        local dims
        dims=$(xdpyinfo 2>/dev/null | grep dimensions | awk '{print $2}')
        if [ -n "$dims" ]; then
            width=$(echo "$dims" | cut -dx -f1)
            height=$(echo "$dims" | cut -dx -f2)
        fi
    fi

    echo "$width $height"
}

# Calculate window geometry for external positioning
# Arguments:
#   $1 = slot (1-4), $2 = total_players, $3 = screen_width, $4 = screen_height
# Outputs: "x y width height"
calculateWindowPosition() {
    local slot=$1
    local total_players=$2
    local screen_width=$3
    local screen_height=$4

    case "$total_players" in
        1)
            echo "0 0 $screen_width $screen_height"
            ;;
        2)
            local half_height=$((screen_height / 2))
            case "$slot" in
                1) echo "0 0 $screen_width $half_height" ;;
                2) echo "0 $half_height $screen_width $half_height" ;;
            esac
            ;;
        3|4)
            local half_width=$((screen_width / 2))
            local half_height=$((screen_height / 2))
            case "$slot" in
                1) echo "0 0 $half_width $half_height" ;;
                2) echo "$half_width 0 $half_width $half_height" ;;
                3) echo "0 $half_height $half_width $half_height" ;;
                4) echo "$half_width $half_height $half_width $half_height" ;;
            esac
            ;;
    esac
}

# Reposition all active windows for new player count
# Arguments:
#   $1 = new total player count
repositionAllWindows() {
    local new_total=$1
    local screen_width screen_height

    read -r screen_width screen_height < <(getScreenDimensions)

    if canUseExternalWindowManagement; then
        log_info "Repositioning windows via xdotool/wmctrl for $new_total players"

        local slot_num=0
        for i in 1 2 3 4; do
            local idx=$((i - 1))
            if [ "${INSTANCE_ACTIVE[$idx]}" = "1" ]; then
                slot_num=$((slot_num + 1))
                local pid="${INSTANCE_PIDS[$idx]}"
                local window_id
                window_id=$(getWindowIdForPid "$pid")

                if [ -n "$window_id" ]; then
                    local x y w h
                    read -r x y w h < <(calculateWindowPosition "$slot_num" "$new_total" "$screen_width" "$screen_height")
                    moveResizeWindow "$window_id" "$x" "$y" "$w" "$h"
                    log "Repositioned window for slot $i to ${x},${y} ${w}x${h}"
                else
                    log_warning "Could not find window for instance $i (PID: $pid)"
                fi
            fi
        done
    else
        log_warning "External window management not available"
        log_info "Updating splitscreen.properties and restarting instances"
        repositionWithRestart "$new_total"
    fi
}

# Reposition by restarting instances (Game Mode fallback)
# Arguments:
#   $1 = new total player count
repositionWithRestart() {
    local new_total=$1

    log_info "Restarting instances for $new_total-player layout"

    # Stop all instances
    for i in 1 2 3 4; do
        local idx=$((i - 1))
        if [ "${INSTANCE_ACTIVE[$idx]}" = "1" ]; then
            local pid="${INSTANCE_PIDS[$idx]}"
            if [ -n "$pid" ]; then
                log "Stopping instance $i for repositioning"
                kill "$pid" 2>/dev/null || true
            fi
        fi
    done

    # Wait for all to exit
    sleep 2

    # Relaunch active instances with new positions
    local slot_num=0
    for i in 1 2 3 4; do
        local idx=$((i - 1))
        if [ "${INSTANCE_ACTIVE[$idx]}" = "1" ]; then
            slot_num=$((slot_num + 1))
            launchInstanceForSlot "$i" "$new_total"
        fi
    done
}

# =============================================================================
# Splitscreen Configuration
# =============================================================================

# Write splitscreen.properties for a player instance
# Arguments:
#   $1 = Player number (1-4)
#   $2 = Total number of controllers/players
setSplitscreenModeForPlayer() {
    local player=$1
    local numberOfControllers=$2
    local config_path="$INSTANCES_DIR/latestUpdate-${player}/.minecraft/config/splitscreen.properties"

    mkdir -p "$(dirname "$config_path")"

    local mode="FULLSCREEN"
    case "$numberOfControllers" in
        1)
            mode="FULLSCREEN"
            ;;
        2)
            if [ "$player" = 1 ]; then mode="TOP"; else mode="BOTTOM"; fi
            ;;
        3)
            if [ "$player" = 1 ]; then mode="TOP"
            elif [ "$player" = 2 ]; then mode="BOTTOM_LEFT"
            else mode="BOTTOM_RIGHT"; fi
            ;;
        4)
            if [ "$player" = 1 ]; then mode="TOP_LEFT"
            elif [ "$player" = 2 ]; then mode="TOP_RIGHT"
            elif [ "$player" = 3 ]; then mode="BOTTOM_LEFT"
            else mode="BOTTOM_RIGHT"; fi
            ;;
    esac

    echo -e "gap=1\nmode=$mode" > "$config_path"
    sync
    sleep 0.5
}

# =============================================================================
# Dynamic Splitscreen Event Handlers (Rev 3.0.0)
# =============================================================================
# Event handlers for dynamic player join/leave functionality.

# Show desktop notification (if available)
# Arguments:
#   $1 = title, $2 = message
showNotification() {
    local title="$1"
    local message="$2"

    if command -v notify-send >/dev/null 2>&1; then
        notify-send -a "Minecraft Splitscreen" "$title" "$message" 2>/dev/null || true
    fi
}

# Handle controller count change event
# Arguments:
#   $1 = new controller count
handleControllerChange() {
    local new_controller_count=$1
    local current_active
    current_active=$(countActiveInstances)

    log_info "Controller change: $new_controller_count controllers (currently $current_active active)"

    # Add new instances if controllers increased and we have room
    while [ "$current_active" -lt "$new_controller_count" ] && [ "$current_active" -lt 4 ]; do
        local slot
        slot=$(getNextAvailableSlot)
        if [ -n "$slot" ]; then
            local new_total=$((current_active + 1))
            log_info "Player $new_total joining (slot $slot)"
            showNotification "Player Joined" "Player $new_total is joining the game"

            # Update ALL windows for new layout FIRST
            if [ "$current_active" -gt 0 ]; then
                repositionAllWindows "$new_total"
            fi

            # Launch the new instance
            launchInstanceForSlot "$slot" "$new_total"
            current_active=$new_total
        else
            break
        fi
    done

    CURRENT_PLAYER_COUNT=$current_active
}

# Check for and handle exited instances
# Called periodically to detect when players quit
checkForExitedInstances() {
    local any_exited=0

    for i in 1 2 3 4; do
        local idx=$((i - 1))
        if [ "${INSTANCE_ACTIVE[$idx]}" = "1" ]; then
            if ! isInstanceRunning "$i"; then
                log_info "Player $i has exited"
                showNotification "Player Left" "Player $i has left the game"
                markInstanceStopped "$i"
                any_exited=1
            fi
        fi
    done

    if [ "$any_exited" = "1" ]; then
        local remaining
        remaining=$(countActiveInstances)
        CURRENT_PLAYER_COUNT=$remaining

        if [ "$remaining" -gt 0 ]; then
            log_info "Repositioning for $remaining remaining players"
            repositionAllWindows "$remaining"
        fi
    fi
}

# =============================================================================
# Dynamic Splitscreen Mode (Rev 3.0.0)
# =============================================================================
# Main loop for dynamic player join/leave mode.

# Run dynamic splitscreen mode - players can join/leave mid-session
runDynamicSplitscreen() {
    log_info "Starting dynamic splitscreen mode"
    DYNAMIC_MODE=1
    local instances_ever_launched=0

    hidePanels

    # Start controller monitoring
    if ! startControllerMonitor; then
        log_error "Failed to start controller monitor, falling back to static mode"
        runStaticSplitscreen
        return
    fi

    # Initial launch based on current controllers
    local initial_count
    initial_count=$(getControllerCount)
    if [ "$initial_count" -gt 0 ]; then
        handleControllerChange "$initial_count"
        instances_ever_launched=1
    else
        log_info "No controllers detected. Waiting for controller connection..."
        showNotification "Waiting for Controllers" "Connect a controller to start playing"
    fi

    # Main event loop
    while true; do
        # Check for controller events (non-blocking read with timeout)
        if read -t 1 -u 3 event 2>/dev/null; then
            if [[ "$event" =~ ^CONTROLLER_CHANGE:([0-9]+)$ ]]; then
                handleControllerChange "${BASH_REMATCH[1]}"
                instances_ever_launched=1
            fi
        fi

        # Check for exited instances
        checkForExitedInstances

        # Exit if all players have left (and at least one ever played)
        local active
        active=$(countActiveInstances)
        if [ "$active" -eq 0 ] && [ "$instances_ever_launched" = "1" ]; then
            log_info "All players have exited. Ending session."
            break
        fi
    done

    # Cleanup
    stopControllerMonitor
    restorePanels
    log_info "Dynamic splitscreen session ended"
}

# Run static splitscreen mode (original behavior)
runStaticSplitscreen() {
    log_info "Starting static splitscreen mode"
    DYNAMIC_MODE=0

    hidePanels

    local numberOfControllers
    numberOfControllers=$(getControllerCount)

    echo "[Info] Detected $numberOfControllers controller(s), launching splitscreen instances..."

    for player in $(seq 1 "$numberOfControllers"); do
        setSplitscreenModeForPlayer "$player" "$numberOfControllers"
        echo "[Info] Launching instance $player of $numberOfControllers (latestUpdate-$player)"
        launchGame "latestUpdate-$player" "P$player"
    done

    echo "[Info] All instances launched. Waiting for games to exit..."
    wait
    restorePanels
    echo "[Info] All games have exited."
}

# =============================================================================
# Main Game Launch Logic
# =============================================================================

# Launch all games based on controller count
launchGames() {
    hidePanels

    local numberOfControllers
    numberOfControllers=$(getControllerCount)

    for player in $(seq 1 $numberOfControllers); do
        setSplitscreenModeForPlayer "$player" "$numberOfControllers"
        launchGame "latestUpdate-$player" "P$player"
    done

    wait
    restorePanels
    sleep 2
}

# =============================================================================
# Steam Deck Detection
# =============================================================================

# Returns 0 if running in Steam Deck Game Mode or equivalent (Bazzite, ChimeraOS, etc.)
# This determines whether we need a nested Plasma session for proper window management
#
# We need a nested session when:
#   - Running in gamescope (no traditional window manager)
#   - Running in Steam's game mode without a full desktop
#
# We DON'T need a nested session when:
#   - Running in a full KDE/GNOME desktop (even if Steam Big Picture is running)
#   - User switched from game mode to desktop mode
isSteamDeckGameMode() {
    local dmi_file="/sys/class/dmi/id/product_name"
    local dmi_contents=""

    if [ -f "$dmi_file" ]; then
        dmi_contents="$(cat "$dmi_file" 2>/dev/null)"
    fi

    # Check 1: Running in gamescope session (Steam Deck Game Mode or Bazzite Game Mode)
    # This is the most reliable indicator - gamescope IS game mode
    if [ "$XDG_SESSION_DESKTOP" = "gamescope" ] || [ "$XDG_CURRENT_DESKTOP" = "gamescope" ]; then
        echo "[Debug] Detected gamescope session" >&2
        return 0
    fi

    # Check 2: Running in KDE/other full desktop - this is DESKTOP mode, not game mode
    # Even if launched from startplasma-steamos, if we're in KDE, we have window management
    if [ -n "$DISPLAY" ] && [[ "$XDG_CURRENT_DESKTOP" =~ ^(KDE|GNOME|XFCE|MATE|Cinnamon|LXQt)$ ]]; then
        echo "[Debug] Desktop mode detected (full desktop environment: $XDG_CURRENT_DESKTOP)" >&2
        return 1
    fi

    # Check 3: Steam Deck hardware with gamepadui (and not in desktop mode)
    if echo "$dmi_contents" | grep -Ei 'Steam Deck|Jupiter' >/dev/null; then
        if pgrep -af 'steam' | grep -q -- '-gamepadui'; then
            echo "[Debug] Detected Steam Deck with gamepadui" >&2
            return 0
        fi
    fi

    # Check 4: No display at all - likely running in pure game mode
    if [ -z "$DISPLAY" ] && [ -z "$WAYLAND_DISPLAY" ]; then
        echo "[Debug] No display - assuming game mode" >&2
        return 0
    fi

    echo "[Debug] Desktop mode detected (default fallback)" >&2
    return 1
}

# =============================================================================
# Cleanup
# =============================================================================

# Remove autostart file on script exit
cleanup_autostart() {
    rm -f "$HOME/.config/autostart/minecraft-launch.desktop"
}
trap cleanup_autostart EXIT

# =============================================================================
# MAIN ENTRY POINT
# =============================================================================

# Enable debug output with SPLITSCREEN_DEBUG=1
if [ "${SPLITSCREEN_DEBUG:-0}" = "1" ]; then
    echo "[Debug] === Minecraft Splitscreen Launcher v__SCRIPT_VERSION__ ===" >&2
    echo "[Debug] Launcher: $LAUNCHER_NAME ($LAUNCHER_TYPE)" >&2
    echo "[Debug] Instances: $INSTANCES_DIR" >&2
    echo "[Debug] Environment: XDG_CURRENT_DESKTOP=$XDG_CURRENT_DESKTOP DISPLAY=$DISPLAY" >&2
fi

# Mode selection (skip if launched with argument)
LAUNCH_MODE="${1:-}"

# Handle special arguments
if [ "$LAUNCH_MODE" != "launchFromPlasma" ] && [ "$LAUNCH_MODE" != "static" ] && [ "$LAUNCH_MODE" != "dynamic" ]; then
    # Interactive mode selection
    echo ""
    echo "=== Minecraft Splitscreen Launcher v__SCRIPT_VERSION__ ==="
    echo ""
    echo "Launch Modes:"
    echo "  1. Static  - Launch based on current controllers (original behavior)"
    echo "  2. Dynamic - Players can join/leave during session [NEW in v3.0]"
    echo ""
    read -t 15 -p "Select mode [1]: " mode_choice </dev/tty 2>/dev/null || mode_choice=""
    mode_choice=${mode_choice:-1}

    case "$mode_choice" in
        2|dynamic|d) LAUNCH_MODE="dynamic" ;;
        *) LAUNCH_MODE="static" ;;
    esac
    echo ""
fi

if isSteamDeckGameMode; then
    if [ "$1" = "launchFromPlasma" ]; then
        # Inside nested Plasma session - check for stored mode
        rm -f ~/.config/autostart/minecraft-launch.desktop

        # Read stored mode from temp file (set by outer invocation)
        stored_mode=""
        if [ -f "/tmp/mc-splitscreen-mode" ]; then
            stored_mode=$(cat "/tmp/mc-splitscreen-mode" 2>/dev/null)
            rm -f "/tmp/mc-splitscreen-mode"
        fi

        if [ "$stored_mode" = "dynamic" ]; then
            runDynamicSplitscreen
        else
            launchGames
        fi

        qdbus org.kde.Shutdown /Shutdown org.kde.Shutdown.logout
    else
        # Store mode for nested session and start it
        echo "$LAUNCH_MODE" > "/tmp/mc-splitscreen-mode"
        nestedPlasma
    fi
else
    # Desktop mode: launch directly with selected mode
    if [ "$LAUNCH_MODE" = "dynamic" ]; then
        runDynamicSplitscreen
    else
        runStaticSplitscreen
    fi
fi
LAUNCHER_SCRIPT_EOF

    # Replace placeholders with actual values
    # Use | as delimiter since paths may contain /
    sed -i "s|__LAUNCHER_NAME__|${launcher_name}|g" "$output_path"
    sed -i "s|__LAUNCHER_TYPE__|${launcher_type}|g" "$output_path"
    sed -i "s|__LAUNCHER_EXEC__|${launcher_exec}|g" "$output_path"
    sed -i "s|__LAUNCHER_DIR__|${launcher_dir}|g" "$output_path"
    sed -i "s|__INSTANCES_DIR__|${instances_dir}|g" "$output_path"
    sed -i "s|__SCRIPT_VERSION__|${SCRIPT_VERSION:-3.0.0}|g" "$output_path"
    sed -i "s|__COMMIT_HASH__|${commit_hash}|g" "$output_path"
    sed -i "s|__GENERATION_DATE__|${generation_date}|g" "$output_path"
    sed -i "s|__REPO_URL__|${REPO_URL:-https://github.com/aradanmn/MinecraftSplitscreenSteamdeck}|g" "$output_path"

    # Make executable
    chmod +x "$output_path"

    print_success "Generated launcher script: $output_path"
    return 0
}

# =============================================================================
# UTILITY FUNCTIONS
# =============================================================================

# @function    verify_generated_script
# @description Verify that a generated launcher script is valid.
#              Checks existence, permissions, placeholder replacement, and syntax.
# @param       $1 - script_path: Path to the generated script
# @return      0 if valid, 1 if invalid
# @example
#   if verify_generated_script "/path/to/script.sh"; then echo "Valid"; fi
verify_generated_script() {
    local script_path="$1"

    if [[ ! -f "$script_path" ]]; then
        print_error "Generated script not found: $script_path"
        return 1
    fi

    if [[ ! -x "$script_path" ]]; then
        print_error "Generated script is not executable: $script_path"
        return 1
    fi

    # Check for placeholder remnants
    if grep -q '__LAUNCHER_' "$script_path"; then
        print_error "Generated script contains unreplaced placeholders"
        return 1
    fi

    # Basic syntax check
    if ! bash -n "$script_path" 2>/dev/null; then
        print_error "Generated script has syntax errors"
        return 1
    fi

    print_success "Generated script verified: $script_path"
    return 0
}

# @function    print_generation_config
# @description Print the configuration that would be used for script generation.
#              Useful for debugging and verification.
# @param       $1-$6 - Same as generate_splitscreen_launcher
# @stdout      Formatted configuration summary
# @return      0 always
print_generation_config() {
    local output_path="$1"
    local launcher_name="$2"
    local launcher_type="$3"
    local launcher_exec="$4"
    local launcher_dir="$5"
    local instances_dir="$6"

    echo "=== Launcher Script Generation Config ==="
    echo "Output:       $output_path"
    echo "Launcher:     $launcher_name"
    echo "Type:         $launcher_type"
    echo "Executable:   $launcher_exec"
    echo "Data Dir:     $launcher_dir"
    echo "Instances:    $instances_dir"
    echo "Version:      ${SCRIPT_VERSION:-3.0.0}"
    echo "=========================================="
}
