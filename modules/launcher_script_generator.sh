#!/bin/bash
# =============================================================================
# @file        launcher_script_generator.sh
# @version     2.0.0
# @date        2026-01-25
# @author      Minecraft Splitscreen Steam Deck Project
# @license     MIT
# @repository  https://github.com/aradanmn/MinecraftSplitscreenSteamdeck
#
# @description
#   Generates the minecraftSplitscreen.sh launcher script with correct paths
#   baked in based on the detected launcher configuration. The generated script
#   handles Steam Deck Game Mode detection, controller counting, splitscreen
#   configuration, and instance launching.
#
#   Key features:
#   - Template-based script generation with placeholder replacement
#   - Support for both AppImage and Flatpak launchers
#   - Steam Deck Game Mode detection with nested Plasma session
#   - Controller detection with Steam Input duplicate handling
#   - Per-instance splitscreen.properties configuration
#
# @dependencies
#   - git (for commit hash embedding, optional)
#   - sed (for placeholder replacement)
#
# @exports
#   Functions:
#     - generate_splitscreen_launcher : Main generation function
#     - verify_generated_script       : Validation utility
#     - print_generation_config       : Debug/info utility
#
# @changelog
#   2.0.0 (2026-01-25) - Added comprehensive JSDoc documentation
#   1.0.0 (2024-XX-XX) - Initial implementation
# =============================================================================

# =============================================================================
# MAIN GENERATOR FUNCTION
# =============================================================================

# @function    generate_splitscreen_launcher
# @description Generate the minecraftSplitscreen.sh launcher script with
#              configuration values baked in via placeholder replacement.
# @param       $1 - output_path: Path for the generated script
# @param       $2 - launcher_name: "PollyMC" or "PrismLauncher"
# @param       $3 - launcher_type: "appimage" or "flatpak"
# @param       $4 - launcher_exec: Full path or flatpak command
# @param       $5 - launcher_dir: Launcher data directory
# @param       $6 - instances_dir: Instances directory path
# @global      SCRIPT_VERSION - (input, optional) Version string for embedding
# @global      REPO_URL - (input, optional) Repository URL for embedding
# @return      0 on success
# @example
#   generate_splitscreen_launcher "/path/to/script.sh" "PollyMC" "flatpak" \
#       "flatpak run org.fn2006.PollyMC" "/home/user/.var/app/org.fn2006.PollyMC/data/PollyMC" \
#       "/home/user/.var/app/org.fn2006.PollyMC/data/PollyMC/instances"
generate_splitscreen_launcher() {
    local output_path="$1"
    local launcher_name="$2"
    local launcher_type="$3"
    local launcher_exec="$4"
    local launcher_dir="$5"
    local instances_dir="$6"

    # Get version info
    local generation_date
    local commit_hash
    generation_date=$(date -Iseconds 2>/dev/null || date "+%Y-%m-%dT%H:%M:%S%z")
    commit_hash=$(git rev-parse --short HEAD 2>/dev/null || echo "unknown")

    # Ensure output directory exists
    mkdir -p "$(dirname "$output_path")"

    # Generate the script using heredoc
    # Note: We use a mix of quoted and unquoted heredoc markers:
    # - 'EOF' (quoted) prevents variable expansion in the heredoc
    # - We then use sed to replace placeholders with actual values
    cat > "$output_path" << 'LAUNCHER_SCRIPT_EOF'
#!/bin/bash
# =============================================================================
# Minecraft Splitscreen Launcher for Steam Deck & Linux
# =============================================================================
# Version: __SCRIPT_VERSION__ (commit: __COMMIT_HASH__)
# Generated: __GENERATION_DATE__
# Generator: install-minecraft-splitscreen.sh v__SCRIPT_VERSION__
# Source: __REPO_URL__
#
# DO NOT EDIT - This file is auto-generated by the installer.
# To update, re-run the installer script.
# =============================================================================
#
# This script launches 1-4 Minecraft instances in splitscreen mode.
# On Steam Deck Game Mode, it launches a nested KDE Plasma session.
# On desktop mode, it launches Minecraft instances directly.
#
# Features:
# - Controller detection (1-4 players)
# - Per-instance splitscreen configuration
# - KDE panel hiding/restoring
# - Steam Input duplicate device handling
# - Nested Plasma session for Steam Deck Game Mode
# =============================================================================

set +e  # Allow script to continue on errors for robustness

# =============================================================================
# GENERATED CONFIGURATION - DO NOT MODIFY
# =============================================================================
# These values were set by the installer based on your system configuration.

LAUNCHER_NAME="__LAUNCHER_NAME__"
LAUNCHER_TYPE="__LAUNCHER_TYPE__"
LAUNCHER_EXEC="__LAUNCHER_EXEC__"
LAUNCHER_DIR="__LAUNCHER_DIR__"
INSTANCES_DIR="__INSTANCES_DIR__"

# =============================================================================
# END GENERATED CONFIGURATION
# =============================================================================

# Temporary directory for intermediate files (respects TMPDIR if set)
export target="${TMPDIR:-/tmp}"

# =============================================================================
# LOGGING (prints to terminal AND logs to file)
# =============================================================================

LOG_DIR="$HOME/.local/share/MinecraftSplitscreen/logs"
LOG_FILE=""

_init_log() {
    mkdir -p "$LOG_DIR" 2>/dev/null || { LOG_DIR="/tmp/MinecraftSplitscreen/logs"; mkdir -p "$LOG_DIR"; }
    LOG_FILE="$LOG_DIR/launcher-$(date +%Y-%m-%d-%H%M%S).log"
    # Rotate old logs (keep last 10)
    local c=0; while IFS= read -r f; do c=$((c+1)); [[ $c -gt 10 ]] && rm -f "$f"; done < <(ls -t "$LOG_DIR"/launcher-*.log 2>/dev/null)
    { echo "=== Minecraft Splitscreen Launcher ==="; echo "Started: $(date)"; echo ""; } >> "$LOG_FILE"
}

log() { [[ -n "$LOG_FILE" ]] && echo "[$(date '+%H:%M:%S')] $*" >> "$LOG_FILE" 2>/dev/null; }
log_info() { echo "[Info] $*"; log "INFO: $*"; }
log_error() { echo "[Error] $*" >&2; log "ERROR: $*"; }
log_warning() { echo "[Warning] $*"; log "WARNING: $*"; }
log_debug() { echo "[Debug] $*" >&2; log "DEBUG: $*"; }

_init_log

# =============================================================================
# Launcher Validation
# =============================================================================

# Validate that the configured launcher is available
validate_launcher() {
    local launcher_available=false

    if [[ "$LAUNCHER_TYPE" == "flatpak" ]]; then
        # For Flatpak, check if the app is installed
        local flatpak_id
        case "$LAUNCHER_NAME" in
            "PollyMC") flatpak_id="org.fn2006.PollyMC" ;;
            "PrismLauncher") flatpak_id="org.prismlauncher.PrismLauncher" ;;
        esac
        if command -v flatpak >/dev/null 2>&1 && flatpak list --app 2>/dev/null | grep -q "$flatpak_id"; then
            launcher_available=true
        fi
    else
        # For AppImage, check if the executable exists
        # Handle both direct path and "flatpak run" style commands
        local exec_path
        exec_path=$(echo "$LAUNCHER_EXEC" | awk '{print $1}')
        if [[ -x "$exec_path" ]] || command -v "$exec_path" >/dev/null 2>&1; then
            launcher_available=true
        fi
    fi

    if [[ "$launcher_available" == false ]]; then
        log_error "$LAUNCHER_NAME not found!"
        log_error "Expected: $LAUNCHER_EXEC"
        log_error "Please re-run the Minecraft Splitscreen installer."
        return 1
    fi

    return 0
}

# Validate launcher at startup
if ! validate_launcher; then
    exit 1
fi

log_info "Using $LAUNCHER_NAME ($LAUNCHER_TYPE) for splitscreen gameplay"
log_info "Log file: $LOG_FILE"

# =============================================================================
# Nested Plasma Session (Steam Deck Game Mode)
# =============================================================================

# Launches a nested KDE Plasma Wayland session and sets up Minecraft autostart.
# Needed so Minecraft can run in a clean, isolated desktop environment.
nestedPlasma() {
    # Unset variables that may interfere with launching a nested session
    unset LD_PRELOAD XDG_DESKTOP_PORTAL_DIR XDG_SEAT_PATH XDG_SESSION_PATH

    # Get current screen resolution
    local RES
    RES=$(xdpyinfo 2>/dev/null | awk '/dimensions/{print $2}')
    [ -z "$RES" ] && RES="1280x800"

    # Create a wrapper for kwin_wayland with the correct resolution
    cat <<EOF > "$target/kwin_wayland_wrapper"
#!/bin/bash
/usr/bin/kwin_wayland_wrapper --width ${RES%x*} --height ${RES#*x} --no-lockscreen \$@
EOF
    chmod +x "$target/kwin_wayland_wrapper"
    export PATH="$target:$PATH"

    # Write an autostart .desktop file that will re-invoke this script
    local SCRIPT_PATH
    SCRIPT_PATH="$(readlink -f "$0")"
    mkdir -p ~/.config/autostart
    cat <<EOF > ~/.config/autostart/minecraft-launch.desktop
[Desktop Entry]
Name=Minecraft Split Launch
Exec=$SCRIPT_PATH launchFromPlasma
Type=Application
X-KDE-AutostartScript=true
EOF

    # Start nested Plasma session (never returns)
    exec dbus-run-session startplasma-wayland
}

# =============================================================================
# Game Launching
# =============================================================================

# Launch a single Minecraft instance with KDE inhibition
# Arguments:
#   $1 = Instance name (e.g., latestUpdate-1)
#   $2 = Player name (e.g., P1)
launchGame() {
    local instance_name="$1"
    local player_name="$2"

    if command -v kde-inhibit >/dev/null 2>&1; then
        kde-inhibit --power --screenSaver --colorCorrect --notifications \
            $LAUNCHER_EXEC -l "$instance_name" -a "$player_name" &
    else
        log_warning "kde-inhibit not found. Running $LAUNCHER_NAME without KDE inhibition."
        $LAUNCHER_EXEC -l "$instance_name" -a "$player_name" &
    fi

    sleep 10  # Give time for the instance to start
}

# =============================================================================
# KDE Panel Management
# =============================================================================

# Hide KDE panels by killing plasmashell
hidePanels() {
    if command -v plasmashell >/dev/null 2>&1; then
        pkill plasmashell
        sleep 1
        if pgrep -u "$USER" plasmashell >/dev/null; then
            killall plasmashell
            sleep 1
        fi
        if pgrep -u "$USER" plasmashell >/dev/null; then
            pkill -9 plasmashell
            sleep 1
        fi
    else
        log_info "plasmashell not found. Skipping KDE panel hiding."
    fi
}

# Restore KDE panels by restarting plasmashell
restorePanels() {
    if command -v plasmashell >/dev/null 2>&1; then
        nohup plasmashell >/dev/null 2>&1 &
        sleep 2
    else
        log_info "plasmashell not found. Skipping KDE panel restore."
    fi
}

# =============================================================================
# Hardware Detection
# =============================================================================

# Check if running on Steam Deck hardware
# Returns 0 (true) if Steam Deck hardware detected, 1 (false) otherwise
# Codenames: Jupiter = Steam Deck LCD, Galileo = Steam Deck OLED
isSteamDeckHardware() {
    local dmi_file="/sys/class/dmi/id/product_name"
    if [ -f "$dmi_file" ]; then
        local product_name
        product_name=$(cat "$dmi_file" 2>/dev/null)
        if echo "$product_name" | grep -Ei 'Steam Deck|Jupiter|Galileo' >/dev/null; then
            return 0
        fi
    fi
    return 1
}

# Check if Steam virtual controller is present
# Returns 0 (true) if Steam Virtual Gamepad detected
hasSteamVirtualController() {
    if grep -q "Steam Virtual Gamepad" /proc/bus/input/devices 2>/dev/null; then
        return 0
    fi
    return 1
}

# =============================================================================
# Controller Detection
# =============================================================================

# Detect the number of controllers (0-4)
# Handles Steam Input device duplication when Steam is running
# Returns 0 if no controllers found (keyboard-only mode possible)
getControllerCount() {
    local count=0
    local steam_running=0
    local real_controllers=0

    # Method 1: Count actual gamepad/joystick devices from /proc/bus/input/devices
    # This is more reliable than /dev/input/js* as it works across different udev configs
    # Filter for actual gamepads (have js handler) and exclude virtual/Steam duplicates
    if [ -f /proc/bus/input/devices ]; then
        # Count unique physical controllers by looking at the Handlers line with "js"
        # and filtering by Sysfs path - uhid devices are real, virtual/input are Steam duplicates
        # Note: grep -c exits with 1 when count is 0, so we capture output and default if empty
        real_controllers=$(grep -B5 "Handlers=.*js[0-9]" /proc/bus/input/devices 2>/dev/null | \
            grep -c "Sysfs=.*/uhid/" 2>/dev/null) || true
        real_controllers=${real_controllers:-0}
    fi

    # Method 2: Fallback to /dev/input/js* if method 1 fails
    if [ "$real_controllers" -eq 0 ]; then
        count=$(ls /dev/input/js* 2>/dev/null | wc -l)
    else
        count=$real_controllers
    fi

    # Method 3: Final fallback to sysfs
    if [ "$count" -eq 0 ]; then
        count=$(ls /sys/class/input/js* 2>/dev/null | wc -l)
    fi

    # Check if Steam is running (native or Flatpak) - expanded patterns for Bazzite/SteamOS
    if pgrep -x steam >/dev/null 2>&1 \
        || pgrep -f '/steam$' >/dev/null 2>&1 \
        || pgrep -f 'ubuntu12_32/steam' >/dev/null 2>&1 \
        || pgrep -f '^/app/bin/steam$' >/dev/null 2>&1 \
        || pgrep -f 'flatpak run com.valvesoftware.Steam' >/dev/null 2>&1; then
        steam_running=1
    fi

    # Only halve if we used fallback methods (not the uhid filtering method)
    # The uhid method already filters out Steam duplicates
    if [ "$steam_running" -eq 1 ] && [ "$real_controllers" -eq 0 ]; then
        count=$(( (count + 1) / 2 ))
    fi

    # Special case: Steam Deck hardware without Steam running
    # The Steam Deck's built-in controls show up as 2 js devices (gamepad + touchpads/motion)
    # but it's really just 1 physical controller
    if isSteamDeckHardware && [ "$steam_running" -eq 0 ] && [ "$count" -gt 1 ]; then
        log_debug "Steam Deck hardware detected without Steam - treating as 1 controller (was $count)"
        count=1
    fi

    # Special case: Steam Deck with no external controllers
    # If on Steam Deck AND count is 0 AND Steam virtual controller detected,
    # count the Steam Deck's built-in controls as 1 player
    if [ "$count" -eq 0 ] && isSteamDeckHardware && hasSteamVirtualController; then
        count=1
        log_debug "Steam Deck built-in controls detected as Player 1"
    fi

    # Clamp to maximum of 4 (no minimum - allow 0 for keyboard-only mode)
    [ "$count" -gt 4 ] && count=4

    log_debug "Controller detection: real=$real_controllers, total=$count, steam=$steam_running"
    echo "$count"
}

# Prompt user for controller mode when no controllers detected
# Returns: player count (1 for keyboard mode, 0 to wait/exit)
promptControllerMode() {
    echo ""
    echo "=========================================="
    echo "  No controllers detected!"
    echo "=========================================="
    echo ""
    echo "Options:"
    echo "  1. Launch with keyboard only (1 player)"
    echo "  2. Wait for controller connection"
    echo "  3. Exit"
    echo ""

    # Try to read from /dev/tty for interactive input
    local choice=""
    if [ -t 0 ]; then
        read -r -p "Your choice [1-3]: " choice
    elif [ -e /dev/tty ]; then
        read -r -p "Your choice [1-3]: " choice < /dev/tty
    else
        echo "[Warning] No interactive terminal available, defaulting to keyboard mode"
        choice="1"
    fi

    case "$choice" in
        1)
            echo "[Info] Launching in keyboard-only mode (1 player)"
            log_info "User selected keyboard-only mode"
            echo "1"
            ;;
        2)
            echo "[Info] Waiting for controller connection..."
            echo "[Info] Connect a controller and press Enter to continue, or Ctrl+C to exit"
            log_info "User waiting for controller connection"
            if [ -t 0 ]; then
                read -r
            elif [ -e /dev/tty ]; then
                read -r < /dev/tty
            fi
            # Re-detect controllers after waiting
            local new_count
            new_count=$(getControllerCount)
            if [ "$new_count" -eq 0 ]; then
                echo "[Warning] Still no controllers detected. Launching in keyboard mode."
                echo "1"
            else
                echo "[Info] Detected $new_count controller(s)"
                echo "$new_count"
            fi
            ;;
        3|*)
            echo "[Info] Exiting..."
            log_info "User chose to exit"
            echo "0"
            ;;
    esac
}

# =============================================================================
# Splitscreen Configuration
# =============================================================================

# Write splitscreen.properties for a player instance
# Arguments:
#   $1 = Player number (1-4)
#   $2 = Total number of controllers/players
setSplitscreenModeForPlayer() {
    local player=$1
    local numberOfControllers=$2
    local config_path="$INSTANCES_DIR/latestUpdate-${player}/.minecraft/config/splitscreen.properties"

    mkdir -p "$(dirname "$config_path")"

    local mode="FULLSCREEN"
    case "$numberOfControllers" in
        1)
            mode="FULLSCREEN"
            ;;
        2)
            if [ "$player" = 1 ]; then mode="TOP"; else mode="BOTTOM"; fi
            ;;
        3)
            if [ "$player" = 1 ]; then mode="TOP"
            elif [ "$player" = 2 ]; then mode="BOTTOM_LEFT"
            else mode="BOTTOM_RIGHT"; fi
            ;;
        4)
            if [ "$player" = 1 ]; then mode="TOP_LEFT"
            elif [ "$player" = 2 ]; then mode="TOP_RIGHT"
            elif [ "$player" = 3 ]; then mode="BOTTOM_LEFT"
            else mode="BOTTOM_RIGHT"; fi
            ;;
    esac

    echo -e "gap=1\nmode=$mode" > "$config_path"
    sync
    sleep 0.5
}

# =============================================================================
# Main Game Launch Logic
# =============================================================================

# Launch all games based on controller count
launchGames() {
    hidePanels

    local numberOfControllers
    numberOfControllers=$(getControllerCount)

    for player in $(seq 1 $numberOfControllers); do
        setSplitscreenModeForPlayer "$player" "$numberOfControllers"
        launchGame "latestUpdate-$player" "P$player"
    done

    wait
    restorePanels
    sleep 2
}

# =============================================================================
# Steam Deck Detection
# =============================================================================

# Returns 0 if running in Steam Deck Game Mode or equivalent (Bazzite, ChimeraOS, etc.)
# This determines whether we need a nested Plasma session for proper window management
#
# We need a nested session when:
#   - Running in gamescope (no traditional window manager)
#   - Running in Steam's game mode without a full desktop
#
# We DON'T need a nested session when:
#   - Running in a full KDE/GNOME desktop (even if Steam Big Picture is running)
#   - User switched from game mode to desktop mode
isSteamDeckGameMode() {
    local dmi_file="/sys/class/dmi/id/product_name"
    local dmi_contents=""

    if [ -f "$dmi_file" ]; then
        dmi_contents="$(cat "$dmi_file" 2>/dev/null)"
    fi

    # Check 1: Running in gamescope session (Steam Deck Game Mode or Bazzite Game Mode)
    # This is the most reliable indicator - gamescope IS game mode
    if [ "$XDG_SESSION_DESKTOP" = "gamescope" ] || [ "$XDG_CURRENT_DESKTOP" = "gamescope" ]; then
        log_debug "Detected gamescope session"
        return 0
    fi

    # Check 2: Running in KDE/other full desktop - this is DESKTOP mode, not game mode
    # Even if launched from startplasma-steamos, if we're in KDE, we have window management
    if [ -n "$DISPLAY" ] && [[ "$XDG_CURRENT_DESKTOP" =~ ^(KDE|GNOME|XFCE|MATE|Cinnamon|LXQt)$ ]]; then
        log_debug "Desktop mode detected (full desktop environment: $XDG_CURRENT_DESKTOP)"
        return 1
    fi

    # Check 3: Steam Deck hardware with gamepadui (and not in desktop mode)
    # Codenames: Jupiter = Steam Deck LCD, Galileo = Steam Deck OLED
    if echo "$dmi_contents" | grep -Ei 'Steam Deck|Jupiter|Galileo' >/dev/null; then
        if pgrep -af 'steam' | grep -q -- '-gamepadui'; then
            log_debug "Detected Steam Deck with gamepadui"
            return 0
        fi
    fi

    # Check 4: No display at all - likely running in pure game mode
    if [ -z "$DISPLAY" ] && [ -z "$WAYLAND_DISPLAY" ]; then
        log_debug "No display - assuming game mode"
        return 0
    fi

    log_debug "Desktop mode detected (default fallback)"
    return 1
}

# =============================================================================
# Cleanup
# =============================================================================

# Remove autostart file on script exit
cleanup_autostart() {
    rm -f "$HOME/.config/autostart/minecraft-launch.desktop"
}
trap cleanup_autostart EXIT

# =============================================================================
# MAIN ENTRY POINT
# =============================================================================

# Enable debug output with SPLITSCREEN_DEBUG=1
if [ "${SPLITSCREEN_DEBUG:-0}" = "1" ]; then
    log_debug "=== Minecraft Splitscreen Launcher ==="
    log_debug "Launcher: $LAUNCHER_NAME ($LAUNCHER_TYPE)"
    log_debug "Instances: $INSTANCES_DIR"
    log_debug "Environment: XDG_CURRENT_DESKTOP=$XDG_CURRENT_DESKTOP DISPLAY=$DISPLAY"
fi

if isSteamDeckGameMode; then
    if [ "$1" = launchFromPlasma ]; then
        # Inside nested Plasma session
        rm -f ~/.config/autostart/minecraft-launch.desktop
        launchGames
        qdbus org.kde.Shutdown /Shutdown org.kde.Shutdown.logout
    else
        # Start nested session
        nestedPlasma
    fi
else
    # Desktop mode: launch directly
    numberOfControllers=$(getControllerCount)

    # Handle 0 controllers - prompt user for options
    if [ "$numberOfControllers" -eq 0 ]; then
        numberOfControllers=$(promptControllerMode)
        # If user chose to exit (returned 0), exit gracefully
        if [ "$numberOfControllers" -eq 0 ]; then
            exit 0
        fi
    fi

    echo "[Info] Detected $numberOfControllers controller(s), launching splitscreen instances..."

    for player in $(seq 1 $numberOfControllers); do
        setSplitscreenModeForPlayer "$player" "$numberOfControllers"
        echo "[Info] Launching instance $player of $numberOfControllers (latestUpdate-$player)"
        launchGame "latestUpdate-$player" "P$player"
    done

    echo "[Info] All instances launched. Waiting for games to exit..."
    wait
    echo "[Info] All games have exited."
fi
LAUNCHER_SCRIPT_EOF

    # Replace placeholders with actual values
    # Use | as delimiter since paths may contain /
    sed -i "s|__LAUNCHER_NAME__|${launcher_name}|g" "$output_path"
    sed -i "s|__LAUNCHER_TYPE__|${launcher_type}|g" "$output_path"
    sed -i "s|__LAUNCHER_EXEC__|${launcher_exec}|g" "$output_path"
    sed -i "s|__LAUNCHER_DIR__|${launcher_dir}|g" "$output_path"
    sed -i "s|__INSTANCES_DIR__|${instances_dir}|g" "$output_path"
    sed -i "s|__SCRIPT_VERSION__|${SCRIPT_VERSION:-2.0.0}|g" "$output_path"
    sed -i "s|__COMMIT_HASH__|${commit_hash}|g" "$output_path"
    sed -i "s|__GENERATION_DATE__|${generation_date}|g" "$output_path"
    sed -i "s|__REPO_URL__|${REPO_URL:-https://github.com/aradanmn/MinecraftSplitscreenSteamdeck}|g" "$output_path"

    # Make executable
    chmod +x "$output_path"

    print_success "Generated launcher script: $output_path"
    return 0
}

# =============================================================================
# UTILITY FUNCTIONS
# =============================================================================

# @function    verify_generated_script
# @description Verify that a generated launcher script is valid.
#              Checks existence, permissions, placeholder replacement, and syntax.
# @param       $1 - script_path: Path to the generated script
# @return      0 if valid, 1 if invalid
# @example
#   if verify_generated_script "/path/to/script.sh"; then echo "Valid"; fi
verify_generated_script() {
    local script_path="$1"

    if [[ ! -f "$script_path" ]]; then
        print_error "Generated script not found: $script_path"
        return 1
    fi

    if [[ ! -x "$script_path" ]]; then
        print_error "Generated script is not executable: $script_path"
        return 1
    fi

    # Check for placeholder remnants
    if grep -q '__LAUNCHER_' "$script_path"; then
        print_error "Generated script contains unreplaced placeholders"
        return 1
    fi

    # Basic syntax check
    if ! bash -n "$script_path" 2>/dev/null; then
        print_error "Generated script has syntax errors"
        return 1
    fi

    print_success "Generated script verified: $script_path"
    return 0
}

# @function    print_generation_config
# @description Print the configuration that would be used for script generation.
#              Useful for debugging and verification.
# @param       $1-$6 - Same as generate_splitscreen_launcher
# @stdout      Formatted configuration summary
# @return      0 always
print_generation_config() {
    local output_path="$1"
    local launcher_name="$2"
    local launcher_type="$3"
    local launcher_exec="$4"
    local launcher_dir="$5"
    local instances_dir="$6"

    echo "=== Launcher Script Generation Config ==="
    echo "Output:       $output_path"
    echo "Launcher:     $launcher_name"
    echo "Type:         $launcher_type"
    echo "Executable:   $launcher_exec"
    echo "Data Dir:     $launcher_dir"
    echo "Instances:    $instances_dir"
    echo "Version:      ${SCRIPT_VERSION:-2.0.0}"
    echo "=========================================="
}
