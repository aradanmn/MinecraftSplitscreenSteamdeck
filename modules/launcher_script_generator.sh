#!/bin/bash
# =============================================================================
# @file        launcher_script_generator.sh
# @version     2.0.0
# @date        2026-01-25
# @author      Minecraft Splitscreen Steam Deck Project
# @license     MIT
# @repository  https://github.com/aradanmn/MinecraftSplitscreenSteamdeck
#
# @description
#   Generates the minecraftSplitscreen.sh launcher script with correct paths
#   baked in based on the detected launcher configuration. The generated script
#   handles Steam Deck Game Mode detection, controller counting, splitscreen
#   configuration, and instance launching.
#
#   Key features:
#   - Template-based script generation with placeholder replacement
#   - Support for both AppImage and Flatpak launchers
#   - Steam Deck Game Mode detection with nested Plasma session
#   - Controller detection with Steam Input duplicate handling
#   - Per-instance splitscreen.properties configuration
#
# @dependencies
#   - git (for commit hash embedding, optional)
#   - sed (for placeholder replacement)
#
# @exports
#   Functions:
#     - generate_splitscreen_launcher : Main generation function
#     - verify_generated_script       : Validation utility
#     - print_generation_config       : Debug/info utility
#
# @changelog
#   2.0.0 (2026-01-25) - Added comprehensive JSDoc documentation
#   1.0.0 (2024-XX-XX) - Initial implementation
# =============================================================================

# =============================================================================
# MAIN GENERATOR FUNCTION
# =============================================================================

# @function    generate_splitscreen_launcher
# @description Generate the minecraftSplitscreen.sh launcher script with
#              configuration values baked in via placeholder replacement.
# @param       $1 - output_path: Path for the generated script
# @param       $2 - launcher_name: "PollyMC" or "PrismLauncher"
# @param       $3 - launcher_type: "appimage" or "flatpak"
# @param       $4 - launcher_exec: Full path or flatpak command
# @param       $5 - launcher_dir: Launcher data directory
# @param       $6 - instances_dir: Instances directory path
# @global      SCRIPT_VERSION - (input, optional) Version string for embedding
# @global      REPO_URL - (input, optional) Repository URL for embedding
# @return      0 on success
# @example
#   generate_splitscreen_launcher "/path/to/script.sh" "PollyMC" "flatpak" \
#       "flatpak run org.fn2006.PollyMC" "/home/user/.var/app/org.fn2006.PollyMC/data/PollyMC" \
#       "/home/user/.var/app/org.fn2006.PollyMC/data/PollyMC/instances"
generate_splitscreen_launcher() {
    local output_path="$1"
    local launcher_name="$2"
    local launcher_type="$3"
    local launcher_exec="$4"
    local launcher_dir="$5"
    local instances_dir="$6"

    # Get version info
    local generation_date
    local commit_hash
    generation_date=$(date -Iseconds 2>/dev/null || date "+%Y-%m-%dT%H:%M:%S%z")
    commit_hash=$(git rev-parse --short HEAD 2>/dev/null || echo "unknown")

    # Ensure output directory exists
    mkdir -p "$(dirname "$output_path")"

    # Generate the script using heredoc
    # Note: We use a mix of quoted and unquoted heredoc markers:
    # - 'EOF' (quoted) prevents variable expansion in the heredoc
    # - We then use sed to replace placeholders with actual values
    cat > "$output_path" << 'LAUNCHER_SCRIPT_EOF'
#!/bin/bash
# =============================================================================
# Minecraft Splitscreen Launcher for Steam Deck & Linux
# =============================================================================
# Version: __SCRIPT_VERSION__ (commit: __COMMIT_HASH__)
# Generated: __GENERATION_DATE__
# Generator: install-minecraft-splitscreen.sh v__SCRIPT_VERSION__
# Source: __REPO_URL__
#
# DO NOT EDIT - This file is auto-generated by the installer.
# To update, re-run the installer script.
# =============================================================================
#
# This script launches 1-4 Minecraft instances in splitscreen mode.
# On Steam Deck Game Mode, it launches a nested KDE Plasma session.
# On desktop mode, it launches Minecraft instances directly.
#
# Features:
# - Controller detection (1-4 players)
# - Per-instance splitscreen configuration
# - KDE panel hiding/restoring
# - Steam Input duplicate device handling
# - Nested Plasma session for Steam Deck Game Mode
# =============================================================================

set +e  # Allow script to continue on errors for robustness

# =============================================================================
# GENERATED CONFIGURATION - DO NOT MODIFY
# =============================================================================
# These values were set by the installer based on your system configuration.

LAUNCHER_NAME="__LAUNCHER_NAME__"
LAUNCHER_TYPE="__LAUNCHER_TYPE__"
LAUNCHER_EXEC="__LAUNCHER_EXEC__"
LAUNCHER_DIR="__LAUNCHER_DIR__"
INSTANCES_DIR="__INSTANCES_DIR__"

# =============================================================================
# END GENERATED CONFIGURATION
# =============================================================================

# Temporary directory for intermediate files
export target=/tmp

# =============================================================================
# Launcher Validation
# =============================================================================

# Validate that the configured launcher is available
validate_launcher() {
    local launcher_available=false

    if [[ "$LAUNCHER_TYPE" == "flatpak" ]]; then
        # For Flatpak, check if the app is installed
        local flatpak_id
        case "$LAUNCHER_NAME" in
            "PollyMC") flatpak_id="org.fn2006.PollyMC" ;;
            "PrismLauncher") flatpak_id="org.prismlauncher.PrismLauncher" ;;
        esac
        if command -v flatpak >/dev/null 2>&1 && flatpak list --app 2>/dev/null | grep -q "$flatpak_id"; then
            launcher_available=true
        fi
    else
        # For AppImage, check if the executable exists
        # Handle both direct path and "flatpak run" style commands
        local exec_path
        exec_path=$(echo "$LAUNCHER_EXEC" | awk '{print $1}')
        if [[ -x "$exec_path" ]] || command -v "$exec_path" >/dev/null 2>&1; then
            launcher_available=true
        fi
    fi

    if [[ "$launcher_available" == false ]]; then
        echo "[Error] $LAUNCHER_NAME not found!" >&2
        echo "[Error] Expected: $LAUNCHER_EXEC" >&2
        echo "[Error] Please re-run the Minecraft Splitscreen installer." >&2
        return 1
    fi

    return 0
}

# Validate launcher at startup
if ! validate_launcher; then
    exit 1
fi

echo "[Info] Using $LAUNCHER_NAME ($LAUNCHER_TYPE) for splitscreen gameplay"

# =============================================================================
# Nested Plasma Session (Steam Deck Game Mode)
# =============================================================================

# Launches a nested KDE Plasma Wayland session and sets up Minecraft autostart.
# Needed so Minecraft can run in a clean, isolated desktop environment.
nestedPlasma() {
    # Unset variables that may interfere with launching a nested session
    unset LD_PRELOAD XDG_DESKTOP_PORTAL_DIR XDG_SEAT_PATH XDG_SESSION_PATH

    # Get current screen resolution
    local RES
    RES=$(xdpyinfo 2>/dev/null | awk '/dimensions/{print $2}')
    [ -z "$RES" ] && RES="1280x800"

    # Create a wrapper for kwin_wayland with the correct resolution
    cat <<EOF > "$target/kwin_wayland_wrapper"
#!/bin/bash
/usr/bin/kwin_wayland_wrapper --width ${RES%x*} --height ${RES#*x} --no-lockscreen \$@
EOF
    chmod +x "$target/kwin_wayland_wrapper"
    export PATH="$target:$PATH"

    # Write an autostart .desktop file that will re-invoke this script
    local SCRIPT_PATH
    SCRIPT_PATH="$(readlink -f "$0")"
    mkdir -p ~/.config/autostart
    cat <<EOF > ~/.config/autostart/minecraft-launch.desktop
[Desktop Entry]
Name=Minecraft Split Launch
Exec=$SCRIPT_PATH launchFromPlasma
Type=Application
X-KDE-AutostartScript=true
EOF

    # Start nested Plasma session (never returns)
    exec dbus-run-session startplasma-wayland
}

# =============================================================================
# Game Launching
# =============================================================================

# Launch a single Minecraft instance with KDE inhibition
# Arguments:
#   $1 = Instance name (e.g., latestUpdate-1)
#   $2 = Player name (e.g., P1)
launchGame() {
    local instance_name="$1"
    local player_name="$2"

    if command -v kde-inhibit >/dev/null 2>&1; then
        kde-inhibit --power --screenSaver --colorCorrect --notifications \
            $LAUNCHER_EXEC -l "$instance_name" -a "$player_name" &
    else
        echo "[Warning] kde-inhibit not found. Running $LAUNCHER_NAME without KDE inhibition."
        $LAUNCHER_EXEC -l "$instance_name" -a "$player_name" &
    fi

    sleep 10  # Give time for the instance to start
}

# =============================================================================
# KDE Panel Management
# =============================================================================

# Hide KDE panels by killing plasmashell
hidePanels() {
    if command -v plasmashell >/dev/null 2>&1; then
        pkill plasmashell
        sleep 1
        if pgrep -u "$USER" plasmashell >/dev/null; then
            killall plasmashell
            sleep 1
        fi
        if pgrep -u "$USER" plasmashell >/dev/null; then
            pkill -9 plasmashell
            sleep 1
        fi
    else
        echo "[Info] plasmashell not found. Skipping KDE panel hiding."
    fi
}

# Restore KDE panels by restarting plasmashell
restorePanels() {
    if command -v plasmashell >/dev/null 2>&1; then
        nohup plasmashell >/dev/null 2>&1 &
        sleep 2
    else
        echo "[Info] plasmashell not found. Skipping KDE panel restore."
    fi
}

# =============================================================================
# Controller Detection
# =============================================================================

# Detect the number of controllers (1-4)
# Handles Steam Input device duplication when Steam is running
getControllerCount() {
    local count=0
    local steam_running=0
    local real_controllers=0

    # Method 1: Count actual gamepad/joystick devices from /proc/bus/input/devices
    # This is more reliable than /dev/input/js* as it works across different udev configs
    # Filter for actual gamepads (have js handler) and exclude virtual/Steam duplicates
    if [ -f /proc/bus/input/devices ]; then
        # Count unique physical controllers by looking at the Handlers line with "js"
        # and filtering by Sysfs path - uhid devices are real, virtual/input are Steam duplicates
        real_controllers=$(grep -B5 "Handlers=.*js[0-9]" /proc/bus/input/devices 2>/dev/null | \
            grep -c "Sysfs=.*/uhid/" 2>/dev/null || echo "0")
    fi

    # Method 2: Fallback to /dev/input/js* if method 1 fails
    if [ "$real_controllers" -eq 0 ]; then
        count=$(ls /dev/input/js* 2>/dev/null | wc -l)
    else
        count=$real_controllers
    fi

    # Method 3: Final fallback to sysfs
    if [ "$count" -eq 0 ]; then
        count=$(ls /sys/class/input/js* 2>/dev/null | wc -l)
    fi

    # Check if Steam is running (native or Flatpak) - expanded patterns for Bazzite/SteamOS
    if pgrep -x steam >/dev/null 2>&1 \
        || pgrep -f '/steam$' >/dev/null 2>&1 \
        || pgrep -f 'ubuntu12_32/steam' >/dev/null 2>&1 \
        || pgrep -f '^/app/bin/steam$' >/dev/null 2>&1 \
        || pgrep -f 'flatpak run com.valvesoftware.Steam' >/dev/null 2>&1; then
        steam_running=1
    fi

    # Only halve if we used fallback methods (not the uhid filtering method)
    # The uhid method already filters out Steam duplicates
    if [ "$steam_running" -eq 1 ] && [ "$real_controllers" -eq 0 ]; then
        count=$(( (count + 1) / 2 ))
    fi

    # Clamp between 1 and 4
    [ "$count" -gt 4 ] && count=4
    [ "$count" -lt 1 ] && count=1

    echo "[Debug] Controller detection: real=$real_controllers, total=$count, steam=$steam_running" >&2
    echo "$count"
}

# =============================================================================
# Splitscreen Configuration
# =============================================================================

# Write splitscreen.properties for a player instance
# Arguments:
#   $1 = Player number (1-4)
#   $2 = Total number of controllers/players
setSplitscreenModeForPlayer() {
    local player=$1
    local numberOfControllers=$2
    local config_path="$INSTANCES_DIR/latestUpdate-${player}/.minecraft/config/splitscreen.properties"

    mkdir -p "$(dirname "$config_path")"

    local mode="FULLSCREEN"
    case "$numberOfControllers" in
        1)
            mode="FULLSCREEN"
            ;;
        2)
            if [ "$player" = 1 ]; then mode="TOP"; else mode="BOTTOM"; fi
            ;;
        3)
            if [ "$player" = 1 ]; then mode="TOP"
            elif [ "$player" = 2 ]; then mode="BOTTOM_LEFT"
            else mode="BOTTOM_RIGHT"; fi
            ;;
        4)
            if [ "$player" = 1 ]; then mode="TOP_LEFT"
            elif [ "$player" = 2 ]; then mode="TOP_RIGHT"
            elif [ "$player" = 3 ]; then mode="BOTTOM_LEFT"
            else mode="BOTTOM_RIGHT"; fi
            ;;
    esac

    echo -e "gap=1\nmode=$mode" > "$config_path"
    sync
    sleep 0.5
}

# =============================================================================
# Main Game Launch Logic
# =============================================================================

# Launch all games based on controller count
launchGames() {
    hidePanels

    local numberOfControllers
    numberOfControllers=$(getControllerCount)

    for player in $(seq 1 $numberOfControllers); do
        setSplitscreenModeForPlayer "$player" "$numberOfControllers"
        launchGame "latestUpdate-$player" "P$player"
    done

    wait
    restorePanels
    sleep 2
}

# =============================================================================
# Steam Deck Detection
# =============================================================================

# Returns 0 if running in Steam Deck Game Mode or equivalent (Bazzite, ChimeraOS, etc.)
# This determines whether we need a nested Plasma session for proper window management
#
# We need a nested session when:
#   - Running in gamescope (no traditional window manager)
#   - Running in Steam's game mode without a full desktop
#
# We DON'T need a nested session when:
#   - Running in a full KDE/GNOME desktop (even if Steam Big Picture is running)
#   - User switched from game mode to desktop mode
isSteamDeckGameMode() {
    local dmi_file="/sys/class/dmi/id/product_name"
    local dmi_contents=""

    if [ -f "$dmi_file" ]; then
        dmi_contents="$(cat "$dmi_file" 2>/dev/null)"
    fi

    # Check 1: Running in gamescope session (Steam Deck Game Mode or Bazzite Game Mode)
    # This is the most reliable indicator - gamescope IS game mode
    if [ "$XDG_SESSION_DESKTOP" = "gamescope" ] || [ "$XDG_CURRENT_DESKTOP" = "gamescope" ]; then
        echo "[Debug] Detected gamescope session" >&2
        return 0
    fi

    # Check 2: Running in KDE/other full desktop - this is DESKTOP mode, not game mode
    # Even if launched from startplasma-steamos, if we're in KDE, we have window management
    if [ -n "$DISPLAY" ] && [[ "$XDG_CURRENT_DESKTOP" =~ ^(KDE|GNOME|XFCE|MATE|Cinnamon|LXQt)$ ]]; then
        echo "[Debug] Desktop mode detected (full desktop environment: $XDG_CURRENT_DESKTOP)" >&2
        return 1
    fi

    # Check 3: Steam Deck hardware with gamepadui (and not in desktop mode)
    if echo "$dmi_contents" | grep -Ei 'Steam Deck|Jupiter' >/dev/null; then
        if pgrep -af 'steam' | grep -q -- '-gamepadui'; then
            echo "[Debug] Detected Steam Deck with gamepadui" >&2
            return 0
        fi
    fi

    # Check 4: No display at all - likely running in pure game mode
    if [ -z "$DISPLAY" ] && [ -z "$WAYLAND_DISPLAY" ]; then
        echo "[Debug] No display - assuming game mode" >&2
        return 0
    fi

    echo "[Debug] Desktop mode detected (default fallback)" >&2
    return 1
}

# =============================================================================
# Cleanup
# =============================================================================

# Remove autostart file on script exit
cleanup_autostart() {
    rm -f "$HOME/.config/autostart/minecraft-launch.desktop"
}
trap cleanup_autostart EXIT

# =============================================================================
# MAIN ENTRY POINT
# =============================================================================

# Enable debug output with SPLITSCREEN_DEBUG=1
if [ "${SPLITSCREEN_DEBUG:-0}" = "1" ]; then
    echo "[Debug] === Minecraft Splitscreen Launcher ===" >&2
    echo "[Debug] Launcher: $LAUNCHER_NAME ($LAUNCHER_TYPE)" >&2
    echo "[Debug] Instances: $INSTANCES_DIR" >&2
    echo "[Debug] Environment: XDG_CURRENT_DESKTOP=$XDG_CURRENT_DESKTOP DISPLAY=$DISPLAY" >&2
fi

if isSteamDeckGameMode; then
    if [ "$1" = launchFromPlasma ]; then
        # Inside nested Plasma session
        rm -f ~/.config/autostart/minecraft-launch.desktop
        launchGames
        qdbus org.kde.Shutdown /Shutdown org.kde.Shutdown.logout
    else
        # Start nested session
        nestedPlasma
    fi
else
    # Desktop mode: launch directly
    numberOfControllers=$(getControllerCount)
    echo "[Info] Detected $numberOfControllers controller(s), launching splitscreen instances..."

    for player in $(seq 1 $numberOfControllers); do
        setSplitscreenModeForPlayer "$player" "$numberOfControllers"
        echo "[Info] Launching instance $player of $numberOfControllers (latestUpdate-$player)"
        launchGame "latestUpdate-$player" "P$player"
    done

    echo "[Info] All instances launched. Waiting for games to exit..."
    wait
    echo "[Info] All games have exited."
fi
LAUNCHER_SCRIPT_EOF

    # Replace placeholders with actual values
    # Use | as delimiter since paths may contain /
    sed -i "s|__LAUNCHER_NAME__|${launcher_name}|g" "$output_path"
    sed -i "s|__LAUNCHER_TYPE__|${launcher_type}|g" "$output_path"
    sed -i "s|__LAUNCHER_EXEC__|${launcher_exec}|g" "$output_path"
    sed -i "s|__LAUNCHER_DIR__|${launcher_dir}|g" "$output_path"
    sed -i "s|__INSTANCES_DIR__|${instances_dir}|g" "$output_path"
    sed -i "s|__SCRIPT_VERSION__|${SCRIPT_VERSION:-2.0.0}|g" "$output_path"
    sed -i "s|__COMMIT_HASH__|${commit_hash}|g" "$output_path"
    sed -i "s|__GENERATION_DATE__|${generation_date}|g" "$output_path"
    sed -i "s|__REPO_URL__|${REPO_URL:-https://github.com/aradanmn/MinecraftSplitscreenSteamdeck}|g" "$output_path"

    # Make executable
    chmod +x "$output_path"

    echo "[Info] Generated launcher script: $output_path"
    return 0
}

# =============================================================================
# UTILITY FUNCTIONS
# =============================================================================

# @function    verify_generated_script
# @description Verify that a generated launcher script is valid.
#              Checks existence, permissions, placeholder replacement, and syntax.
# @param       $1 - script_path: Path to the generated script
# @return      0 if valid, 1 if invalid
# @example
#   if verify_generated_script "/path/to/script.sh"; then echo "Valid"; fi
verify_generated_script() {
    local script_path="$1"

    if [[ ! -f "$script_path" ]]; then
        echo "[Error] Generated script not found: $script_path" >&2
        return 1
    fi

    if [[ ! -x "$script_path" ]]; then
        echo "[Error] Generated script is not executable: $script_path" >&2
        return 1
    fi

    # Check for placeholder remnants
    if grep -q '__LAUNCHER_' "$script_path"; then
        echo "[Error] Generated script contains unreplaced placeholders" >&2
        return 1
    fi

    # Basic syntax check
    if ! bash -n "$script_path" 2>/dev/null; then
        echo "[Error] Generated script has syntax errors" >&2
        return 1
    fi

    echo "[Info] Generated script verified: $script_path"
    return 0
}

# @function    print_generation_config
# @description Print the configuration that would be used for script generation.
#              Useful for debugging and verification.
# @param       $1-$6 - Same as generate_splitscreen_launcher
# @stdout      Formatted configuration summary
# @return      0 always
print_generation_config() {
    local output_path="$1"
    local launcher_name="$2"
    local launcher_type="$3"
    local launcher_exec="$4"
    local launcher_dir="$5"
    local instances_dir="$6"

    echo "=== Launcher Script Generation Config ==="
    echo "Output:       $output_path"
    echo "Launcher:     $launcher_name"
    echo "Type:         $launcher_type"
    echo "Executable:   $launcher_exec"
    echo "Data Dir:     $launcher_dir"
    echo "Instances:    $instances_dir"
    echo "Version:      ${SCRIPT_VERSION:-2.0.0}"
    echo "=========================================="
}
